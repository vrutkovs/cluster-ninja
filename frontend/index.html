<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/2.6.2/phaser.min.js"></script>
    <title>Fruit Ninja</title>
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
        }
    </style>
</head>

<body>
    <div id="game"></div>

    <script>
        // Local debugging
        // var backend = "http://localhost:8081/api"
        // Production - use the same URL
        var backend = "/api"

        var w = window.innerWidth,
            h = window.innerHeight;

        var game = new Phaser.Game(w, h, Phaser.AUTO, 'game', {
            preload: preload,
            create: create,
            update: update,
            render: render
        });

        var fruits = ['apple', 'banana', 'cherry', 'orange', 'pineapple', 'pumpkin', 'strawberry'];

        function preload() {
            fruits.forEach(fruit => game.load.image(fruit, `images/fruits/${fruit}.png`));
            game.load.image('bomb', 'images/bomb.png');
            game.load.image('explosion', 'images/explosion.png');
        }

        var good_objects,
            bad_objects,
            slashes,
            line,
            tipLabel,
            scoreLabel,
            chromeLabel,
            fontSize,
            fruitSize,
            score = {},
            points = [];

        var fireRate = 1400;
        var nextFire = 0;
        var label_style = {
            fill: "#ffffff",
            wordWrap: true,
            wordWrapWidth: fruitSize,
            boundsAlignH: "center",
            boundsAlignV: "middle",
        };

        function create() {
            game.physics.startSystem(Phaser.Physics.ARCADE);
            game.physics.arcade.gravity.y = 300;
            game.stage.backgroundColor = "#0d2622";

            good_objects = createGroup(fruits);
            bad_objects = createGroupMultiple(4, 'bomb');

            slashes = game.add.graphics(0, 0);

            emitter = game.add.emitter(0, 0, 300);
            emitter.makeParticles('explosion');
            emitter.gravity = 300;
            emitter.setScale(0.15, 0.3, 0.15, 0.3);
            emitter.setYSpeed(-400, 400);

            fontSize = game.world.width < 500 ? 24 : 40;
            label_style.font = fontSize-5 + "px Arial";
            fruitSize = Math.round(Math.min(game.world.width, game.world.height) * 0.25);

            createText();

            throwObject();
        }

        function createText() {
            tipLabel = game.add.text(10, 10, 'Slice fruits, avoid bombs!');
            tipLabel.fill = 'white';
            tipLabel.fontSize = fontSize;

            scoreLabel = game.add.text(10, 70);
            scoreLabel.fontSize = fontSize;
        }

        function createGroup(sprites) {
            var group = game.add.group();
            group.enableBody = true;
            group.physicsBodyType = Phaser.Physics.ARCADE;
            sprites.forEach(sprite => {
                group.add(game.make.sprite(30000, 30000, sprite));
            })
            group.setAll('checkWorldBounds', true);
            group.setAll('outOfBoundsKill', true);
            return group;
        }

        function createGroupMultiple(numItems, sprite) {
            var group = game.add.group();
            group.enableBody = true;
            group.physicsBodyType = Phaser.Physics.ARCADE;
            group.createMultiple(numItems, sprite);
            group.setAll('checkWorldBounds', true);
            group.setAll('outOfBoundsKill', true);
            return group;
        }

        function throwObject() {
            if (game.time.now > nextFire && good_objects.countDead() > 0 && bad_objects.countDead() > 0) {
                nextFire = game.time.now + fireRate;
                throwGoodObject();
                if (Math.random() > .5) {
                    throwBadObject();
                }
            }
        }

        async function getRandomResource() {
            const response = await fetch(backend + '/gimme')
            const data = await response.json();
            return data;
        }

        async function throwGoodObject() {
            var obj = getRandomDead(good_objects);

            getRandomResource().then(resource => {
                // Exit early if we failed to get the object
                if (typeof resource == "undefined") {
                    return
                }

                resourceText = "ns/"+ resource.namespace + "\n"+resource.type + "/" + resource.name;
                if (obj.children.length == 0) {
                    var label = game.add.text(0, 0, resourceText, label_style);
                    label.setTextBounds(0, 0, fruitSize, fruitSize);
                    label.alpha = 0.7;
                    label.anchor.setTo(0.5, 0.5);
                    obj.addChild(label);
                } else {
                    label = obj.getChildAt(0);
                    label.text = resourceText;
                }

                obj.anchor.setTo(0.5, 0.5);
                obj.angle = getRandomStartingAngle();
                obj.height = obj.width = fruitSize;
                obj.body.angularAcceleration = getRandomAngularAcceleration();
                obj.reset(getRandomX(), game.world.height);
                obj.data = resource;
                game.physics.arcade.moveToXY(obj, game.world.centerX, game.world.centerY, getRandomSpeed());
            })
        }


        function throwBadObject() {
            var obj = bad_objects.getFirstDead();
            obj.reset(getRandomX(), game.world.height);
            obj.anchor.setTo(0.5, 0.5);
            obj.angle = getRandomStartingAngle();
            obj.height = obj.width = fruitSize;
            obj.body.angularAcceleration = getRandomAngularAcceleration();
            game.physics.arcade.moveToXY(obj, game.world.centerX, game.world.centerY, getRandomSpeed());
        }

        function getRandomDead(group) {
            let deadChildren = group.children.filter(function (e) {
                return !e.alive;
            });
            let randIndex = Math.floor((Math.random() * deadChildren.length));
            randIndex = Math.min(randIndex, deadChildren.length - 1);
            return deadChildren[randIndex];
        }

        // get random value between 5 and 50
        function getRandomAngularAcceleration() {
            return Math.floor(Math.random() * (50 - 5 + 1)) + 5;
        }

        // get random angle between -10 and 10
        function getRandomStartingAngle() {
            return ((Math.random() * 2) - 1) * 10;
        }

        // get random x position from the central 60% of the screen
        function getRandomX() {
            return (((Math.random() * game.world.width) - game.world.centerX) * 0.6) + game.world.centerX;
        }

        // get random pixels per second speec, up to 50
        function getRandomSpeed() {
            return Math.max(Math.random() * game.world.height, 10);
        }

        function getInput() {
            return game.input;
        }

        function update() {
            throwObject();
            slashViaInput();
        }

        function slashViaInput() {
            let input = getInput();
            points.push({
                x: input.x,
                y: input.y
            });
            points = points.splice(points.length - 10, points.length);

            if (points.length < 1 || points[0].x == 0) {
                return;
            }

            slashes.clear();
            slashes.beginFill(0xFFFFFF);
            slashes.alpha = .5;
            slashes.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                slashes.lineTo(points[i].x, points[i].y);
            }
            slashes.endFill();

            for (var i = 1; i < points.length; i++) {
                line = new Phaser.Line(points[i].x, points[i].y, points[i - 1].x, points[i - 1].y);
                game.debug.geom(line);

                good_objects.forEachExists(checkIntersects);
                bad_objects.forEachExists(checkIntersects);
            }
        }

        var contactPoint = new Phaser.Point(0, 0);

        function checkIntersects(fruit, callback) {
            var l1 = new Phaser.Line(fruit.body.right - fruit.width, fruit.body.bottom - fruit.height, fruit.body.right,
                fruit.body.bottom);
            var l2 = new Phaser.Line(fruit.body.right - fruit.width, fruit.body.bottom, fruit.body.right, fruit.body
                .bottom - fruit.height);
            l2.angle = 90;

            if (Phaser.Line.intersects(line, l1, true) ||
                Phaser.Line.intersects(line, l2, true)) {

                let input = getInput();
                contactPoint.x = input.x;
                contactPoint.y = input.y;
                var distance = Phaser.Point.distance(contactPoint, new Phaser.Point(fruit.x, fruit.y));
                if (Phaser.Point.distance(contactPoint, new Phaser.Point(fruit.x, fruit.y)) > 110) {
                    return;
                }

                if (fruit.parent == good_objects) {
                    killFruit(fruit);
                } else {
                    killEmAll();
                }
            }
        }

        function killEmAll() {
            good_objects.forEachExists(killFruit);
            bad_objects.forEachExists(killFruit);
        }

        function killFruit(fruit) {
            emitter.x = fruit.x;
            emitter.y = fruit.y;
            emitter.start(true, 2000, null, 4);

            var resource = fruit.data;
            if (typeof resource !== "undefined" && typeof resource.name !== "undefined") {
                fetch(
                    backend+'/destroy/ns/'+resource.namespace+"/"+resource.type+"/"+resource.name,
                    {method: 'POST'});
                if (resource.type in score) {
                    score[resource.type] += 1;
                } else {
                    score[resource.type] = 1;
                }
            }

            fruit.data = {};
            fruit.kill();
            points = [];
            updateScore();

        }

        function updateScore() {
            var labelParts = [];
            for (const [key, value] of Object.entries(score)) {
                labelParts.push(`${key}s: ${value}`);
            }
            scoreLabel.text = labelParts.join(", ");
            scoreLabel.fill = '#9adcfa';
        }

        function render() {}
    </script>

</body>

</html>
